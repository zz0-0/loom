// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:loom/src/rust/frb_generated.dart';

// These functions are ignored because they are not marked as `pub`: `convert_to_internal_block`, `convert_to_internal_document`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ParseProgress`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `parse_blox_file_with_progress`

/// Parse a Blox document from string content
BloxDocument parseBloxString({required String content}) =>
    RustLib.instance.api.crateApiBloxApiParseBloxString(content: content);

/// Parse a Blox document from file
Future<BloxDocument> parseBloxFile({required String filePath}) =>
    RustLib.instance.api.crateApiBloxApiParseBloxFile(filePath: filePath);

/// Encode a Blox document back to string format
String encodeBloxDocument({
  required BloxDocument document,
  required bool useShorthand,
}) =>
    RustLib.instance.api.crateApiBloxApiEncodeBloxDocument(
      document: document,
      useShorthand: useShorthand,
    );

/// Decode a Blox document to specified output format
String decodeBloxDocument({
  required BloxDocument document,
  required BloxOutputFormat format,
}) =>
    RustLib.instance.api
        .crateApiBloxApiDecodeBloxDocument(document: document, format: format);

/// Validate Blox syntax without full parsing
List<String> validateBloxSyntax({required String content}) =>
    RustLib.instance.api.crateApiBloxApiValidateBloxSyntax(content: content);

class BloxBlock {
  const BloxBlock({
    required this.blockType,
    required this.level,
    required this.attributes,
    required this.content,
    required this.children,
    required this.lineNumber,
  });
  final String blockType;
  final BigInt level;
  final Map<String, String> attributes;
  final String content;
  final List<BloxBlock> children;
  final BigInt lineNumber;

  @override
  int get hashCode =>
      blockType.hashCode ^
      level.hashCode ^
      attributes.hashCode ^
      content.hashCode ^
      children.hashCode ^
      lineNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BloxBlock &&
          runtimeType == other.runtimeType &&
          blockType == other.blockType &&
          level == other.level &&
          attributes == other.attributes &&
          content == other.content &&
          children == other.children &&
          lineNumber == other.lineNumber;
}

class BloxDocument {
  const BloxDocument({
    required this.blocks,
    required this.metadata,
  });
  final List<BloxBlock> blocks;
  final Map<String, String> metadata;

  @override
  int get hashCode => blocks.hashCode ^ metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BloxDocument &&
          runtimeType == other.runtimeType &&
          blocks == other.blocks &&
          metadata == other.metadata;
}

enum BloxOutputFormat {
  html,
  markdown,
  json,
  plainText,
  ;
}
